{"ast":null,"code":"\"use strict\";\n\nvar _this = this;\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.parseTIFF = void 0;\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\n\nvar isLittleEndian = function isLittleEndian() {\n  // Get byte order mark.\n  var BOM = getBytes(2, 0); // Find out the endianness.\n\n  if (BOM === 0x4949) {\n    littleEndian = true;\n  } else if (BOM === 0x4d4d) {\n    littleEndian = false;\n  } else {\n    throw TypeError(\"Invalid byte order value.\");\n  }\n\n  return littleEndian;\n};\n\nvar hasTowel = function hasTowel() {\n  // Check for towel.\n  if (getBytes(2, 2) !== 42) {\n    throw RangeError(\"You forgot your towel!\");\n    return false;\n  }\n\n  return true;\n};\n\nvar getFieldTagName = function getFieldTagName(fieldTag) {\n  // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n  // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n  var fieldTagNames = {\n    // TIFF Baseline\n    0x013b: \"Artist\",\n    0x0102: \"BitsPerSample\",\n    0x0109: \"CellLength\",\n    0x0108: \"CellWidth\",\n    0x0140: \"ColorMap\",\n    0x0103: \"Compression\",\n    0x8298: \"Copyright\",\n    0x0132: \"DateTime\",\n    0x0152: \"ExtraSamples\",\n    0x010a: \"FillOrder\",\n    0x0121: \"FreeByteCounts\",\n    0x0120: \"FreeOffsets\",\n    0x0123: \"GrayResponseCurve\",\n    0x0122: \"GrayResponseUnit\",\n    0x013c: \"HostComputer\",\n    0x010e: \"ImageDescription\",\n    0x0101: \"ImageLength\",\n    0x0100: \"ImageWidth\",\n    0x010f: \"Make\",\n    0x0119: \"MaxSampleValue\",\n    0x0118: \"MinSampleValue\",\n    0x0110: \"Model\",\n    0x00fe: \"NewSubfileType\",\n    0x0112: \"Orientation\",\n    0x0106: \"PhotometricInterpretation\",\n    0x011c: \"PlanarConfiguration\",\n    0x0128: \"ResolutionUnit\",\n    0x0116: \"RowsPerStrip\",\n    0x0115: \"SamplesPerPixel\",\n    0x0131: \"Software\",\n    0x0117: \"StripByteCounts\",\n    0x0111: \"StripOffsets\",\n    0x00ff: \"SubfileType\",\n    0x0107: \"Threshholding\",\n    0x011a: \"XResolution\",\n    0x011b: \"YResolution\",\n    // TIFF Extended\n    0x0146: \"BadFaxLines\",\n    0x0147: \"CleanFaxData\",\n    0x0157: \"ClipPath\",\n    0x0148: \"ConsecutiveBadFaxLines\",\n    0x01b1: \"Decode\",\n    0x01b2: \"DefaultImageColor\",\n    0x010d: \"DocumentName\",\n    0x0150: \"DotRange\",\n    0x0141: \"HalftoneHints\",\n    0x015a: \"Indexed\",\n    0x015b: \"JPEGTables\",\n    0x011d: \"PageName\",\n    0x0129: \"PageNumber\",\n    0x013d: \"Predictor\",\n    0x013f: \"PrimaryChromaticities\",\n    0x0214: \"ReferenceBlackWhite\",\n    0x0153: \"SampleFormat\",\n    0x022f: \"StripRowCounts\",\n    0x014a: \"SubIFDs\",\n    0x0124: \"T4Options\",\n    0x0125: \"T6Options\",\n    0x0145: \"TileByteCounts\",\n    0x0143: \"TileLength\",\n    0x0144: \"TileOffsets\",\n    0x0142: \"TileWidth\",\n    0x012d: \"TransferFunction\",\n    0x013e: \"WhitePoint\",\n    0x0158: \"XClipPathUnits\",\n    0x011e: \"XPosition\",\n    0x0211: \"YCbCrCoefficients\",\n    0x0213: \"YCbCrPositioning\",\n    0x0212: \"YCbCrSubSampling\",\n    0x0159: \"YClipPathUnits\",\n    0x011f: \"YPosition\",\n    // EXIF\n    0x9202: \"ApertureValue\",\n    0xa001: \"ColorSpace\",\n    0x9004: \"DateTimeDigitized\",\n    0x9003: \"DateTimeOriginal\",\n    0x8769: \"Exif IFD\",\n    0x9000: \"ExifVersion\",\n    0x829a: \"ExposureTime\",\n    0xa300: \"FileSource\",\n    0x9209: \"Flash\",\n    0xa000: \"FlashpixVersion\",\n    0x829d: \"FNumber\",\n    0xa420: \"ImageUniqueID\",\n    0x9208: \"LightSource\",\n    0x927c: \"MakerNote\",\n    0x9201: \"ShutterSpeedValue\",\n    0x9286: \"UserComment\",\n    // IPTC\n    0x83bb: \"IPTC\",\n    // ICC\n    0x8773: \"ICC Profile\",\n    // XMP\n    0x02bc: \"XMP\",\n    // GDAL\n    0xa480: \"GDAL_METADATA\",\n    0xa481: \"GDAL_NODATA\",\n    // Photoshop\n    0x8649: \"Photoshop\"\n  };\n  var fieldTagName;\n\n  if (fieldTag in fieldTagNames) {\n    fieldTagName = fieldTagNames[fieldTag];\n  } else {\n    fieldTagName = \"Tag\" + fieldTag;\n  }\n\n  return fieldTagName;\n};\n\nvar getFieldTypeName = function getFieldTypeName(fieldType) {\n  var fieldTypeNames = {\n    0x0001: \"BYTE\",\n    0x0002: \"ASCII\",\n    0x0003: \"SHORT\",\n    0x0004: \"LONG\",\n    0x0005: \"RATIONAL\",\n    0x0006: \"SBYTE\",\n    0x0007: \"UNDEFINED\",\n    0x0008: \"SSHORT\",\n    0x0009: \"SLONG\",\n    0x000a: \"SRATIONAL\",\n    0x000b: \"FLOAT\",\n    0x000c: \"DOUBLE\"\n  };\n  var fieldTypeName;\n\n  if (fieldType in fieldTypeNames) {\n    fieldTypeName = fieldTypeNames[fieldType];\n  }\n\n  return fieldTypeName;\n};\n\nvar getFieldTypeLength = function getFieldTypeLength(fieldTypeName) {\n  var fieldTypeLength;\n\n  if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 1;\n  } else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 2;\n  } else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 4;\n  } else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n    fieldTypeLength = 8;\n  }\n\n  return fieldTypeLength;\n};\n\nvar getBits = function getBits(numBits, byteOffset, bitOffset) {\n  bitOffset = bitOffset || 0;\n  var extraBytes = Math.floor(bitOffset / 8);\n  var newByteOffset = byteOffset + extraBytes;\n  var totalBits = bitOffset + numBits;\n  var shiftRight = 32 - numBits;\n\n  if (totalBits <= 0) {\n    throw RangeError(\"No bits requested\");\n  } else if (totalBits <= 8) {\n    var shiftLeft = 24 + bitOffset;\n    var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n  } else if (totalBits <= 16) {\n    var shiftLeft = 16 + bitOffset;\n    var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n  } else if (totalBits <= 32) {\n    var shiftLeft = bitOffset;\n    var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bits requested\");\n  }\n\n  var chunkInfo = {\n    bits: rawBits << shiftLeft >>> shiftRight,\n    byteOffset: newByteOffset + Math.floor(totalBits / 8),\n    bitOffset: totalBits % 8\n  };\n  return chunkInfo;\n};\n\nvar getBytes = function getBytes(numBytes, offset) {\n  if (numBytes <= 0) {\n    throw RangeError(\"No bytes requested\");\n  } else if (numBytes <= 1) {\n    return tiffDataView.getUint8(offset, littleEndian);\n  } else if (numBytes <= 2) {\n    return tiffDataView.getUint16(offset, littleEndian);\n  } else if (numBytes <= 3) {\n    return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n  } else if (numBytes <= 4) {\n    return tiffDataView.getUint32(offset, littleEndian);\n  } else {\n    throw RangeError(\"Too many bytes requested\");\n  }\n};\n\nvar getFieldValues = function getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset) {\n  var fieldValues = [];\n  var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n  var fieldValueSize = fieldTypeLength * typeCount;\n\n  if (fieldValueSize <= 4) {\n    // The value is stored at the big end of the valueOffset.\n    if (littleEndian === false) {\n      var value = valueOffset >>> (4 - fieldTypeLength) * 8;\n    } else {\n      var value = valueOffset;\n    }\n\n    fieldValues.push(value);\n  } else {\n    for (var i = 0; i < typeCount; i++) {\n      var indexOffset = fieldTypeLength * i;\n\n      if (fieldTypeLength >= 8) {\n        if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n          // Numerator\n          fieldValues.push(getBytes(4, valueOffset + indexOffset)); // Denominator\n\n          fieldValues.push(getBytes(4, valueOffset + indexOffset + 4)); //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n          //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n        } else {\n          throw TypeError(\"Can't handle this field type or size\");\n        }\n      } else {\n        fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n      }\n    }\n  }\n\n  if (fieldTypeName === \"ASCII\") {\n    fieldValues.forEach(function (e, i, a) {\n      a[i] = String.fromCharCode(e);\n    });\n  }\n\n  return fieldValues;\n};\n\nvar clampColorSample = function clampColorSample(colorSample, bitsPerSample) {\n  var multiplier = Math.pow(2, 8 - bitsPerSample);\n  return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\n\nvar makeRGBAFillValue = function makeRGBAFillValue(r, g, b, a) {\n  if (typeof a === \"undefined\") {\n    a = 1.0;\n  }\n\n  return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\n\nvar parseFileDirectory = function parseFileDirectory(byteOffset) {\n  var numDirEntries = getBytes(2, byteOffset);\n  var tiffFields = [];\n\n  for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n    var fieldTag = getBytes(2, i);\n    var fieldType = getBytes(2, i + 2);\n    var typeCount = getBytes(4, i + 4);\n    var valueOffset = getBytes(4, i + 8);\n    var fieldTagName = getFieldTagName(fieldTag);\n    var fieldTypeName = getFieldTypeName(fieldType);\n    var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n    tiffFields[fieldTagName] = {\n      type: fieldTypeName,\n      values: fieldValues\n    };\n  }\n\n  fileDirectories.push(tiffFields);\n  var nextIFDByteOffset = getBytes(4, i);\n\n  if (nextIFDByteOffset === 0x00000000) {\n    return fileDirectories;\n  } else {\n    return parseFileDirectory(nextIFDByteOffset);\n  }\n};\n\nexports.parseTIFF = function (tiffArrayBuffer, _canvas) {\n  var canvas = _canvas || document.createElement(\"canvas\");\n\n  if (!tiffArrayBuffer) return;\n  tiffDataView = new DataView(tiffArrayBuffer); // canvas = _canvas;\n\n  littleEndian = isLittleEndian(tiffDataView);\n  if (!hasTowel(tiffDataView, littleEndian)) return;\n  var firstIFDByteOffset = getBytes(4, 4);\n  fileDirectories = parseFileDirectory(firstIFDByteOffset);\n  var fileDirectory = fileDirectories[0];\n  var imageWidth = fileDirectory.ImageWidth.values[0];\n  var imageLength = fileDirectory.ImageLength.values[0];\n  canvas.width = imageWidth;\n  canvas.height = imageLength;\n  var strips = [];\n  var compression = fileDirectory.Compression ? fileDirectory.Compression.values[0] : 1;\n  var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n  var sampleProperties = [];\n  var bitsPerPixel = 0;\n  var hasBytesPerPixel = false;\n  fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n    sampleProperties[i] = {\n      bitsPerSample: bitsPerSample,\n      hasBytesPerSample: false,\n      bytesPerSample: undefined\n    };\n\n    if (bitsPerSample % 8 === 0) {\n      sampleProperties[i].hasBytesPerSample = true;\n      sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n    }\n\n    bitsPerPixel += bitsPerSample;\n  }, _this);\n\n  if (bitsPerPixel % 8 === 0) {\n    hasBytesPerPixel = true;\n    var bytesPerPixel = bitsPerPixel / 8;\n  }\n\n  var stripOffsetValues = fileDirectory.StripOffsets.values;\n  var numStripOffsetValues = stripOffsetValues.length; // StripByteCounts is supposed to be required, but see if we can recover anyway.\n\n  if (fileDirectory.StripByteCounts) {\n    var stripByteCountValues = fileDirectory.StripByteCounts.values;\n  } else {\n    // Infer StripByteCounts, if possible.\n    if (numStripOffsetValues === 1) {\n      var stripByteCountValues = [Math.ceil(imageWidth * imageLength * bitsPerPixel / 8)];\n    } else {\n      throw Error(\"Cannot recover from missing StripByteCounts\");\n    }\n  } // Loop through strips and decompress as necessary.\n\n\n  for (var i = 0; i < numStripOffsetValues; i++) {\n    var stripOffset = stripOffsetValues[i];\n    strips[i] = [];\n    var stripByteCount = stripByteCountValues[i]; // Loop through pixels.\n\n    for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n      // Decompress strip.\n      switch (compression) {\n        // Uncompressed\n        case 1:\n          // Loop through samples (sub-pixels).\n          for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n            if (sampleProperties[m].hasBytesPerSample) {\n              // XXX: This is wrong!\n              var sampleOffset = sampleProperties[m].bytesPerSample * m;\n              pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n            } else {\n              var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n              pixel.push(sampleInfo.bits);\n              byteOffset = sampleInfo.byteOffset - stripOffset;\n              bitOffset = sampleInfo.bitOffset;\n              throw RangeError(\"Cannot handle sub-byte bits per sample\");\n            }\n          }\n\n          strips[i].push(pixel);\n\n          if (hasBytesPerPixel) {\n            jIncrement = bytesPerPixel;\n          } else {\n            jIncrement = 0;\n            throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n          }\n\n          break;\n        // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n\n        case 2:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 3 Fax\n\n        case 3:\n          // XXX: Use PDF.js code?\n          break;\n        // Group 4 Fax\n\n        case 4:\n          // XXX: Use PDF.js code?\n          break;\n        // LZW\n\n        case 5:\n          // XXX: Use PDF.js code?\n          break;\n        // Old-style JPEG (TIFF 6.0)\n\n        case 6:\n          // XXX: Use PDF.js code?\n          break;\n        // New-style JPEG (TIFF Specification Supplement 2)\n\n        case 7:\n          // XXX: Use PDF.js code?\n          break;\n        // PackBits\n\n        case 32773:\n          // Are we ready for a new block?\n          if (getHeader) {\n            getHeader = false;\n            var blockLength = 1;\n            var iterations = 1; // The header byte is signed.\n\n            var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n\n            if (header >= 0 && header <= 127) {\n              // Normal pixels.\n              blockLength = header + 1;\n            } else if (header >= -127 && header <= -1) {\n              // Collapsed pixels.\n              iterations = -header + 1;\n            }\n            /*if (header === -128)*/\n            else {\n                // Placeholder byte?\n                getHeader = true;\n              }\n          } else {\n            var currentByte = getBytes(1, stripOffset + byteOffset); // Duplicate bytes, if necessary.\n\n            for (var m = 0; m < iterations; m++) {\n              if (sampleProperties[sample].hasBytesPerSample) {\n                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                currentSample = currentSample << 8 * numBytes | currentByte;\n                numBytes++; // Is our sample complete?\n\n                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                  pixel.push(currentSample);\n                  currentSample = numBytes = 0;\n                  sample++;\n                }\n              } else {\n                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n              } // Is our pixel complete?\n\n\n              if (sample === samplesPerPixel) {\n                strips[i].push(pixel);\n                pixel = [];\n                sample = 0;\n              }\n            }\n\n            blockLength--; // Is our block complete?\n\n            if (blockLength === 0) {\n              getHeader = true;\n            }\n          }\n\n          jIncrement = 1;\n          break;\n        // Unknown compression algorithm\n\n        default:\n          // Do not attempt to parse the image data.\n          break;\n      }\n    }\n  }\n\n  if (canvas.getContext) {\n    var ctx = canvas.getContext(\"2d\"); // Set a default fill style.\n\n    ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0); // If RowsPerStrip is missing, the whole image is in one strip.\n\n    if (fileDirectory.RowsPerStrip) {\n      var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n    } else {\n      var rowsPerStrip = imageLength;\n    }\n\n    var numStrips = strips.length;\n    var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n    var rowsInLastStrip = imageLengthModRowsPerStrip === 0 ? rowsPerStrip : imageLengthModRowsPerStrip;\n    var numRowsInStrip = rowsPerStrip;\n    var numRowsInPreviousStrip = 0;\n    var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n    var extraSamplesValues = [];\n    var numExtraSamples = 0;\n\n    if (fileDirectory.ExtraSamples) {\n      extraSamplesValues = fileDirectory.ExtraSamples.values;\n      numExtraSamples = extraSamplesValues.length;\n    }\n\n    if (fileDirectory.ColorMap) {\n      var colorMapValues = fileDirectory.ColorMap.values;\n      var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n    } // Loop through the strips in the image.\n\n\n    for (var i = 0; i < numStrips; i++) {\n      // The last strip may be short.\n      if (i + 1 === numStrips) {\n        numRowsInStrip = rowsInLastStrip;\n      }\n\n      var numPixels = strips[i].length;\n      var yPadding = numRowsInPreviousStrip * i; // Loop through the rows in the strip.\n\n      for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n        // Loop through the pixels in the row.\n        for (var x = 0; x < imageWidth; x++, j++) {\n          var pixelSamples = strips[i][j];\n          var red = 0;\n          var green = 0;\n          var blue = 0;\n          var opacity = 1.0;\n\n          if (numExtraSamples > 0) {\n            for (var k = 0; k < numExtraSamples; k++) {\n              if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                // Clamp opacity to the range [0,1].\n                opacity = pixelSamples[3 + k] / 256;\n                break;\n              }\n            }\n          }\n\n          switch (photometricInterpretation) {\n            // Bilevel or Grayscale\n            // WhiteIsZero\n            case 0:\n              if (sampleProperties[0].hasBytesPerSample) {\n                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n              } // Invert samples.\n\n\n              pixelSamples.forEach(function (sample, index, samples) {\n                samples[index] = invertValue - sample;\n              });\n            // Bilevel or Grayscale\n            // BlackIsZero\n\n            case 1:\n              red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              break;\n            // RGB Full Color\n\n            case 2:\n              red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n              green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n              blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n              break;\n            // RGB Color Palette\n\n            case 3:\n              if (colorMapValues === undefined) {\n                throw Error(\"Palette image missing color map\");\n              }\n\n              var colorMapIndex = pixelSamples[0];\n              red = clampColorSample(colorMapValues[colorMapIndex], 16);\n              green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n              blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n              break;\n            // Transparency mask\n\n            case 4:\n              throw RangeError(\"Not Yet Implemented: Transparency mask\");\n              break;\n            // CMYK\n\n            case 5:\n              throw RangeError(\"Not Yet Implemented: CMYK\");\n              break;\n            // YCbCr\n\n            case 6:\n              throw RangeError(\"Not Yet Implemented: YCbCr\");\n              break;\n            // CIELab\n\n            case 8:\n              throw RangeError(\"Not Yet Implemented: CIELab\");\n              break;\n            // Unknown Photometric Interpretation\n\n            default:\n              throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n              break;\n          }\n\n          ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n          ctx.fillRect(x, yPadding + y, 1, 1);\n        }\n      }\n\n      numRowsInPreviousStrip = numRowsInStrip;\n    }\n  }\n\n  return canvas;\n};","map":{"version":3,"sources":["C:/xampp/htdocs/mdbreact/node_modules/react-doc-viewer/build/plugins/tiff/tiffToCanvas.js"],"names":["_this","Object","defineProperty","exports","value","parseTIFF","tiffDataView","undefined","littleEndian","fileDirectories","isLittleEndian","BOM","getBytes","TypeError","hasTowel","RangeError","getFieldTagName","fieldTag","fieldTagNames","fieldTagName","getFieldTypeName","fieldType","fieldTypeNames","fieldTypeName","getFieldTypeLength","fieldTypeLength","indexOf","getBits","numBits","byteOffset","bitOffset","extraBytes","Math","floor","newByteOffset","totalBits","shiftRight","shiftLeft","rawBits","getUint8","getUint16","getUint32","chunkInfo","bits","numBytes","offset","getFieldValues","typeCount","valueOffset","fieldValues","fieldValueSize","push","i","indexOffset","forEach","e","a","String","fromCharCode","clampColorSample","colorSample","bitsPerSample","multiplier","pow","makeRGBAFillValue","r","g","b","parseFileDirectory","numDirEntries","tiffFields","entryCount","type","values","nextIFDByteOffset","tiffArrayBuffer","_canvas","canvas","document","createElement","DataView","firstIFDByteOffset","fileDirectory","imageWidth","ImageWidth","imageLength","ImageLength","width","height","strips","compression","Compression","samplesPerPixel","SamplesPerPixel","sampleProperties","bitsPerPixel","hasBytesPerPixel","BitsPerSample","bitsPerSampleValues","hasBytesPerSample","bytesPerSample","bytesPerPixel","stripOffsetValues","StripOffsets","numStripOffsetValues","length","StripByteCounts","stripByteCountValues","ceil","Error","stripOffset","stripByteCount","jIncrement","getHeader","pixel","sample","currentSample","m","sampleOffset","sampleInfo","blockLength","iterations","header","getInt8","currentByte","getContext","ctx","fillStyle","RowsPerStrip","rowsPerStrip","numStrips","imageLengthModRowsPerStrip","rowsInLastStrip","numRowsInStrip","numRowsInPreviousStrip","photometricInterpretation","PhotometricInterpretation","extraSamplesValues","numExtraSamples","ExtraSamples","ColorMap","colorMapValues","colorMapSampleSize","numPixels","yPadding","y","j","x","pixelSamples","red","green","blue","opacity","k","invertValue","index","samples","colorMapIndex","fillRect"],"mappings":"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","sourcesContent":["\"use strict\";\nvar _this = this;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseTIFF = void 0;\nvar tiffDataView = undefined;\nvar littleEndian = undefined;\nvar fileDirectories = [];\nvar isLittleEndian = function () {\n    // Get byte order mark.\n    var BOM = getBytes(2, 0);\n    // Find out the endianness.\n    if (BOM === 0x4949) {\n        littleEndian = true;\n    }\n    else if (BOM === 0x4d4d) {\n        littleEndian = false;\n    }\n    else {\n        throw TypeError(\"Invalid byte order value.\");\n    }\n    return littleEndian;\n};\nvar hasTowel = function () {\n    // Check for towel.\n    if (getBytes(2, 2) !== 42) {\n        throw RangeError(\"You forgot your towel!\");\n        return false;\n    }\n    return true;\n};\nvar getFieldTagName = function (fieldTag) {\n    // See: http://www.digitizationguidelines.gov/guidelines/TIFF_Metadata_Final.pdf\n    // See: http://www.digitalpreservation.gov/formats/content/tiff_tags.shtml\n    var fieldTagNames = {\n        // TIFF Baseline\n        0x013b: \"Artist\",\n        0x0102: \"BitsPerSample\",\n        0x0109: \"CellLength\",\n        0x0108: \"CellWidth\",\n        0x0140: \"ColorMap\",\n        0x0103: \"Compression\",\n        0x8298: \"Copyright\",\n        0x0132: \"DateTime\",\n        0x0152: \"ExtraSamples\",\n        0x010a: \"FillOrder\",\n        0x0121: \"FreeByteCounts\",\n        0x0120: \"FreeOffsets\",\n        0x0123: \"GrayResponseCurve\",\n        0x0122: \"GrayResponseUnit\",\n        0x013c: \"HostComputer\",\n        0x010e: \"ImageDescription\",\n        0x0101: \"ImageLength\",\n        0x0100: \"ImageWidth\",\n        0x010f: \"Make\",\n        0x0119: \"MaxSampleValue\",\n        0x0118: \"MinSampleValue\",\n        0x0110: \"Model\",\n        0x00fe: \"NewSubfileType\",\n        0x0112: \"Orientation\",\n        0x0106: \"PhotometricInterpretation\",\n        0x011c: \"PlanarConfiguration\",\n        0x0128: \"ResolutionUnit\",\n        0x0116: \"RowsPerStrip\",\n        0x0115: \"SamplesPerPixel\",\n        0x0131: \"Software\",\n        0x0117: \"StripByteCounts\",\n        0x0111: \"StripOffsets\",\n        0x00ff: \"SubfileType\",\n        0x0107: \"Threshholding\",\n        0x011a: \"XResolution\",\n        0x011b: \"YResolution\",\n        // TIFF Extended\n        0x0146: \"BadFaxLines\",\n        0x0147: \"CleanFaxData\",\n        0x0157: \"ClipPath\",\n        0x0148: \"ConsecutiveBadFaxLines\",\n        0x01b1: \"Decode\",\n        0x01b2: \"DefaultImageColor\",\n        0x010d: \"DocumentName\",\n        0x0150: \"DotRange\",\n        0x0141: \"HalftoneHints\",\n        0x015a: \"Indexed\",\n        0x015b: \"JPEGTables\",\n        0x011d: \"PageName\",\n        0x0129: \"PageNumber\",\n        0x013d: \"Predictor\",\n        0x013f: \"PrimaryChromaticities\",\n        0x0214: \"ReferenceBlackWhite\",\n        0x0153: \"SampleFormat\",\n        0x022f: \"StripRowCounts\",\n        0x014a: \"SubIFDs\",\n        0x0124: \"T4Options\",\n        0x0125: \"T6Options\",\n        0x0145: \"TileByteCounts\",\n        0x0143: \"TileLength\",\n        0x0144: \"TileOffsets\",\n        0x0142: \"TileWidth\",\n        0x012d: \"TransferFunction\",\n        0x013e: \"WhitePoint\",\n        0x0158: \"XClipPathUnits\",\n        0x011e: \"XPosition\",\n        0x0211: \"YCbCrCoefficients\",\n        0x0213: \"YCbCrPositioning\",\n        0x0212: \"YCbCrSubSampling\",\n        0x0159: \"YClipPathUnits\",\n        0x011f: \"YPosition\",\n        // EXIF\n        0x9202: \"ApertureValue\",\n        0xa001: \"ColorSpace\",\n        0x9004: \"DateTimeDigitized\",\n        0x9003: \"DateTimeOriginal\",\n        0x8769: \"Exif IFD\",\n        0x9000: \"ExifVersion\",\n        0x829a: \"ExposureTime\",\n        0xa300: \"FileSource\",\n        0x9209: \"Flash\",\n        0xa000: \"FlashpixVersion\",\n        0x829d: \"FNumber\",\n        0xa420: \"ImageUniqueID\",\n        0x9208: \"LightSource\",\n        0x927c: \"MakerNote\",\n        0x9201: \"ShutterSpeedValue\",\n        0x9286: \"UserComment\",\n        // IPTC\n        0x83bb: \"IPTC\",\n        // ICC\n        0x8773: \"ICC Profile\",\n        // XMP\n        0x02bc: \"XMP\",\n        // GDAL\n        0xa480: \"GDAL_METADATA\",\n        0xa481: \"GDAL_NODATA\",\n        // Photoshop\n        0x8649: \"Photoshop\",\n    };\n    var fieldTagName;\n    if (fieldTag in fieldTagNames) {\n        fieldTagName = fieldTagNames[fieldTag];\n    }\n    else {\n        fieldTagName = \"Tag\" + fieldTag;\n    }\n    return fieldTagName;\n};\nvar getFieldTypeName = function (fieldType) {\n    var fieldTypeNames = {\n        0x0001: \"BYTE\",\n        0x0002: \"ASCII\",\n        0x0003: \"SHORT\",\n        0x0004: \"LONG\",\n        0x0005: \"RATIONAL\",\n        0x0006: \"SBYTE\",\n        0x0007: \"UNDEFINED\",\n        0x0008: \"SSHORT\",\n        0x0009: \"SLONG\",\n        0x000a: \"SRATIONAL\",\n        0x000b: \"FLOAT\",\n        0x000c: \"DOUBLE\",\n    };\n    var fieldTypeName;\n    if (fieldType in fieldTypeNames) {\n        fieldTypeName = fieldTypeNames[fieldType];\n    }\n    return fieldTypeName;\n};\nvar getFieldTypeLength = function (fieldTypeName) {\n    var fieldTypeLength;\n    if ([\"BYTE\", \"ASCII\", \"SBYTE\", \"UNDEFINED\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 1;\n    }\n    else if ([\"SHORT\", \"SSHORT\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 2;\n    }\n    else if ([\"LONG\", \"SLONG\", \"FLOAT\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 4;\n    }\n    else if ([\"RATIONAL\", \"SRATIONAL\", \"DOUBLE\"].indexOf(fieldTypeName) !== -1) {\n        fieldTypeLength = 8;\n    }\n    return fieldTypeLength;\n};\nvar getBits = function (numBits, byteOffset, bitOffset) {\n    bitOffset = bitOffset || 0;\n    var extraBytes = Math.floor(bitOffset / 8);\n    var newByteOffset = byteOffset + extraBytes;\n    var totalBits = bitOffset + numBits;\n    var shiftRight = 32 - numBits;\n    if (totalBits <= 0) {\n        throw RangeError(\"No bits requested\");\n    }\n    else if (totalBits <= 8) {\n        var shiftLeft = 24 + bitOffset;\n        var rawBits = tiffDataView.getUint8(newByteOffset, littleEndian);\n    }\n    else if (totalBits <= 16) {\n        var shiftLeft = 16 + bitOffset;\n        var rawBits = tiffDataView.getUint16(newByteOffset, littleEndian);\n    }\n    else if (totalBits <= 32) {\n        var shiftLeft = bitOffset;\n        var rawBits = tiffDataView.getUint32(newByteOffset, littleEndian);\n    }\n    else {\n        throw RangeError(\"Too many bits requested\");\n    }\n    var chunkInfo = {\n        bits: (rawBits << shiftLeft) >>> shiftRight,\n        byteOffset: newByteOffset + Math.floor(totalBits / 8),\n        bitOffset: totalBits % 8,\n    };\n    return chunkInfo;\n};\nvar getBytes = function (numBytes, offset) {\n    if (numBytes <= 0) {\n        throw RangeError(\"No bytes requested\");\n    }\n    else if (numBytes <= 1) {\n        return tiffDataView.getUint8(offset, littleEndian);\n    }\n    else if (numBytes <= 2) {\n        return tiffDataView.getUint16(offset, littleEndian);\n    }\n    else if (numBytes <= 3) {\n        return tiffDataView.getUint32(offset, littleEndian) >>> 8;\n    }\n    else if (numBytes <= 4) {\n        return tiffDataView.getUint32(offset, littleEndian);\n    }\n    else {\n        throw RangeError(\"Too many bytes requested\");\n    }\n};\nvar getFieldValues = function (fieldTagName, fieldTypeName, typeCount, valueOffset) {\n    var fieldValues = [];\n    var fieldTypeLength = getFieldTypeLength(fieldTypeName);\n    var fieldValueSize = fieldTypeLength * typeCount;\n    if (fieldValueSize <= 4) {\n        // The value is stored at the big end of the valueOffset.\n        if (littleEndian === false) {\n            var value = valueOffset >>> ((4 - fieldTypeLength) * 8);\n        }\n        else {\n            var value = valueOffset;\n        }\n        fieldValues.push(value);\n    }\n    else {\n        for (var i = 0; i < typeCount; i++) {\n            var indexOffset = fieldTypeLength * i;\n            if (fieldTypeLength >= 8) {\n                if ([\"RATIONAL\", \"SRATIONAL\"].indexOf(fieldTypeName) !== -1) {\n                    // Numerator\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset));\n                    // Denominator\n                    fieldValues.push(getBytes(4, valueOffset + indexOffset + 4));\n                    //\t\t\t\t\t} else if (['DOUBLE'].indexOf(fieldTypeName) !== -1) {\n                    //\t\t\t\t\t\tfieldValues.push(getBytes(4, valueOffset + indexOffset) + getBytes(4, valueOffset + indexOffset + 4));\n                }\n                else {\n                    throw TypeError(\"Can't handle this field type or size\");\n                }\n            }\n            else {\n                fieldValues.push(getBytes(fieldTypeLength, valueOffset + indexOffset));\n            }\n        }\n    }\n    if (fieldTypeName === \"ASCII\") {\n        fieldValues.forEach(function (e, i, a) {\n            a[i] = String.fromCharCode(e);\n        });\n    }\n    return fieldValues;\n};\nvar clampColorSample = function (colorSample, bitsPerSample) {\n    var multiplier = Math.pow(2, 8 - bitsPerSample);\n    return Math.floor(colorSample * multiplier + (multiplier - 1));\n};\nvar makeRGBAFillValue = function (r, g, b, a) {\n    if (typeof a === \"undefined\") {\n        a = 1.0;\n    }\n    return \"rgba(\" + r + \", \" + g + \", \" + b + \", \" + a + \")\";\n};\nvar parseFileDirectory = function (byteOffset) {\n    var numDirEntries = getBytes(2, byteOffset);\n    var tiffFields = [];\n    for (var i = byteOffset + 2, entryCount = 0; entryCount < numDirEntries; i += 12, entryCount++) {\n        var fieldTag = getBytes(2, i);\n        var fieldType = getBytes(2, i + 2);\n        var typeCount = getBytes(4, i + 4);\n        var valueOffset = getBytes(4, i + 8);\n        var fieldTagName = getFieldTagName(fieldTag);\n        var fieldTypeName = getFieldTypeName(fieldType);\n        var fieldValues = getFieldValues(fieldTagName, fieldTypeName, typeCount, valueOffset);\n        tiffFields[fieldTagName] = { type: fieldTypeName, values: fieldValues };\n    }\n    fileDirectories.push(tiffFields);\n    var nextIFDByteOffset = getBytes(4, i);\n    if (nextIFDByteOffset === 0x00000000) {\n        return fileDirectories;\n    }\n    else {\n        return parseFileDirectory(nextIFDByteOffset);\n    }\n};\nexports.parseTIFF = function (tiffArrayBuffer, _canvas) {\n    var canvas = _canvas || document.createElement(\"canvas\");\n    if (!tiffArrayBuffer)\n        return;\n    tiffDataView = new DataView(tiffArrayBuffer);\n    // canvas = _canvas;\n    littleEndian = isLittleEndian(tiffDataView);\n    if (!hasTowel(tiffDataView, littleEndian))\n        return;\n    var firstIFDByteOffset = getBytes(4, 4);\n    fileDirectories = parseFileDirectory(firstIFDByteOffset);\n    var fileDirectory = fileDirectories[0];\n    var imageWidth = fileDirectory.ImageWidth.values[0];\n    var imageLength = fileDirectory.ImageLength.values[0];\n    canvas.width = imageWidth;\n    canvas.height = imageLength;\n    var strips = [];\n    var compression = fileDirectory.Compression\n        ? fileDirectory.Compression.values[0]\n        : 1;\n    var samplesPerPixel = fileDirectory.SamplesPerPixel.values[0];\n    var sampleProperties = [];\n    var bitsPerPixel = 0;\n    var hasBytesPerPixel = false;\n    fileDirectory.BitsPerSample.values.forEach(function (bitsPerSample, i, bitsPerSampleValues) {\n        sampleProperties[i] = {\n            bitsPerSample: bitsPerSample,\n            hasBytesPerSample: false,\n            bytesPerSample: undefined,\n        };\n        if (bitsPerSample % 8 === 0) {\n            sampleProperties[i].hasBytesPerSample = true;\n            sampleProperties[i].bytesPerSample = bitsPerSample / 8;\n        }\n        bitsPerPixel += bitsPerSample;\n    }, _this);\n    if (bitsPerPixel % 8 === 0) {\n        hasBytesPerPixel = true;\n        var bytesPerPixel = bitsPerPixel / 8;\n    }\n    var stripOffsetValues = fileDirectory.StripOffsets.values;\n    var numStripOffsetValues = stripOffsetValues.length;\n    // StripByteCounts is supposed to be required, but see if we can recover anyway.\n    if (fileDirectory.StripByteCounts) {\n        var stripByteCountValues = fileDirectory.StripByteCounts.values;\n    }\n    else {\n        // Infer StripByteCounts, if possible.\n        if (numStripOffsetValues === 1) {\n            var stripByteCountValues = [\n                Math.ceil((imageWidth * imageLength * bitsPerPixel) / 8),\n            ];\n        }\n        else {\n            throw Error(\"Cannot recover from missing StripByteCounts\");\n        }\n    }\n    // Loop through strips and decompress as necessary.\n    for (var i = 0; i < numStripOffsetValues; i++) {\n        var stripOffset = stripOffsetValues[i];\n        strips[i] = [];\n        var stripByteCount = stripByteCountValues[i];\n        // Loop through pixels.\n        for (var byteOffset = 0, bitOffset = 0, jIncrement = 1, getHeader = true, pixel = [], numBytes = 0, sample = 0, currentSample = 0; byteOffset < stripByteCount; byteOffset += jIncrement) {\n            // Decompress strip.\n            switch (compression) {\n                // Uncompressed\n                case 1:\n                    // Loop through samples (sub-pixels).\n                    for (var m = 0, pixel = []; m < samplesPerPixel; m++) {\n                        if (sampleProperties[m].hasBytesPerSample) {\n                            // XXX: This is wrong!\n                            var sampleOffset = sampleProperties[m].bytesPerSample * m;\n                            pixel.push(getBytes(sampleProperties[m].bytesPerSample, stripOffset + byteOffset + sampleOffset));\n                        }\n                        else {\n                            var sampleInfo = getBits(sampleProperties[m].bitsPerSample, stripOffset + byteOffset, bitOffset);\n                            pixel.push(sampleInfo.bits);\n                            byteOffset = sampleInfo.byteOffset - stripOffset;\n                            bitOffset = sampleInfo.bitOffset;\n                            throw RangeError(\"Cannot handle sub-byte bits per sample\");\n                        }\n                    }\n                    strips[i].push(pixel);\n                    if (hasBytesPerPixel) {\n                        jIncrement = bytesPerPixel;\n                    }\n                    else {\n                        jIncrement = 0;\n                        throw RangeError(\"Cannot handle sub-byte bits per pixel\");\n                    }\n                    break;\n                // CITT Group 3 1-Dimensional Modified Huffman run-length encoding\n                case 2:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Group 3 Fax\n                case 3:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Group 4 Fax\n                case 4:\n                    // XXX: Use PDF.js code?\n                    break;\n                // LZW\n                case 5:\n                    // XXX: Use PDF.js code?\n                    break;\n                // Old-style JPEG (TIFF 6.0)\n                case 6:\n                    // XXX: Use PDF.js code?\n                    break;\n                // New-style JPEG (TIFF Specification Supplement 2)\n                case 7:\n                    // XXX: Use PDF.js code?\n                    break;\n                // PackBits\n                case 32773:\n                    // Are we ready for a new block?\n                    if (getHeader) {\n                        getHeader = false;\n                        var blockLength = 1;\n                        var iterations = 1;\n                        // The header byte is signed.\n                        var header = tiffDataView.getInt8(stripOffset + byteOffset, littleEndian);\n                        if (header >= 0 && header <= 127) {\n                            // Normal pixels.\n                            blockLength = header + 1;\n                        }\n                        else if (header >= -127 && header <= -1) {\n                            // Collapsed pixels.\n                            iterations = -header + 1;\n                        } /*if (header === -128)*/\n                        else {\n                            // Placeholder byte?\n                            getHeader = true;\n                        }\n                    }\n                    else {\n                        var currentByte = getBytes(1, stripOffset + byteOffset);\n                        // Duplicate bytes, if necessary.\n                        for (var m = 0; m < iterations; m++) {\n                            if (sampleProperties[sample].hasBytesPerSample) {\n                                // We're reading one byte at a time, so we need to handle multi-byte samples.\n                                currentSample = (currentSample << (8 * numBytes)) | currentByte;\n                                numBytes++;\n                                // Is our sample complete?\n                                if (numBytes === sampleProperties[sample].bytesPerSample) {\n                                    pixel.push(currentSample);\n                                    currentSample = numBytes = 0;\n                                    sample++;\n                                }\n                            }\n                            else {\n                                throw RangeError(\"Cannot handle sub-byte bits per sample\");\n                            }\n                            // Is our pixel complete?\n                            if (sample === samplesPerPixel) {\n                                strips[i].push(pixel);\n                                pixel = [];\n                                sample = 0;\n                            }\n                        }\n                        blockLength--;\n                        // Is our block complete?\n                        if (blockLength === 0) {\n                            getHeader = true;\n                        }\n                    }\n                    jIncrement = 1;\n                    break;\n                // Unknown compression algorithm\n                default:\n                    // Do not attempt to parse the image data.\n                    break;\n            }\n        }\n    }\n    if (canvas.getContext) {\n        var ctx = canvas.getContext(\"2d\");\n        // Set a default fill style.\n        ctx.fillStyle = makeRGBAFillValue(255, 255, 255, 0);\n        // If RowsPerStrip is missing, the whole image is in one strip.\n        if (fileDirectory.RowsPerStrip) {\n            var rowsPerStrip = fileDirectory.RowsPerStrip.values[0];\n        }\n        else {\n            var rowsPerStrip = imageLength;\n        }\n        var numStrips = strips.length;\n        var imageLengthModRowsPerStrip = imageLength % rowsPerStrip;\n        var rowsInLastStrip = imageLengthModRowsPerStrip === 0\n            ? rowsPerStrip\n            : imageLengthModRowsPerStrip;\n        var numRowsInStrip = rowsPerStrip;\n        var numRowsInPreviousStrip = 0;\n        var photometricInterpretation = fileDirectory.PhotometricInterpretation.values[0];\n        var extraSamplesValues = [];\n        var numExtraSamples = 0;\n        if (fileDirectory.ExtraSamples) {\n            extraSamplesValues = fileDirectory.ExtraSamples.values;\n            numExtraSamples = extraSamplesValues.length;\n        }\n        if (fileDirectory.ColorMap) {\n            var colorMapValues = fileDirectory.ColorMap.values;\n            var colorMapSampleSize = Math.pow(2, sampleProperties[0].bitsPerSample);\n        }\n        // Loop through the strips in the image.\n        for (var i = 0; i < numStrips; i++) {\n            // The last strip may be short.\n            if (i + 1 === numStrips) {\n                numRowsInStrip = rowsInLastStrip;\n            }\n            var numPixels = strips[i].length;\n            var yPadding = numRowsInPreviousStrip * i;\n            // Loop through the rows in the strip.\n            for (var y = 0, j = 0; y < numRowsInStrip, j < numPixels; y++) {\n                // Loop through the pixels in the row.\n                for (var x = 0; x < imageWidth; x++, j++) {\n                    var pixelSamples = strips[i][j];\n                    var red = 0;\n                    var green = 0;\n                    var blue = 0;\n                    var opacity = 1.0;\n                    if (numExtraSamples > 0) {\n                        for (var k = 0; k < numExtraSamples; k++) {\n                            if (extraSamplesValues[k] === 1 || extraSamplesValues[k] === 2) {\n                                // Clamp opacity to the range [0,1].\n                                opacity = pixelSamples[3 + k] / 256;\n                                break;\n                            }\n                        }\n                    }\n                    switch (photometricInterpretation) {\n                        // Bilevel or Grayscale\n                        // WhiteIsZero\n                        case 0:\n                            if (sampleProperties[0].hasBytesPerSample) {\n                                var invertValue = Math.pow(0x10, sampleProperties[0].bytesPerSample * 2);\n                            }\n                            // Invert samples.\n                            pixelSamples.forEach(function (sample, index, samples) {\n                                samples[index] = invertValue - sample;\n                            });\n                        // Bilevel or Grayscale\n                        // BlackIsZero\n                        case 1:\n                            red = green = blue = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n                            break;\n                        // RGB Full Color\n                        case 2:\n                            red = clampColorSample(pixelSamples[0], sampleProperties[0].bitsPerSample);\n                            green = clampColorSample(pixelSamples[1], sampleProperties[1].bitsPerSample);\n                            blue = clampColorSample(pixelSamples[2], sampleProperties[2].bitsPerSample);\n                            break;\n                        // RGB Color Palette\n                        case 3:\n                            if (colorMapValues === undefined) {\n                                throw Error(\"Palette image missing color map\");\n                            }\n                            var colorMapIndex = pixelSamples[0];\n                            red = clampColorSample(colorMapValues[colorMapIndex], 16);\n                            green = clampColorSample(colorMapValues[colorMapSampleSize + colorMapIndex], 16);\n                            blue = clampColorSample(colorMapValues[2 * colorMapSampleSize + colorMapIndex], 16);\n                            break;\n                        // Transparency mask\n                        case 4:\n                            throw RangeError(\"Not Yet Implemented: Transparency mask\");\n                            break;\n                        // CMYK\n                        case 5:\n                            throw RangeError(\"Not Yet Implemented: CMYK\");\n                            break;\n                        // YCbCr\n                        case 6:\n                            throw RangeError(\"Not Yet Implemented: YCbCr\");\n                            break;\n                        // CIELab\n                        case 8:\n                            throw RangeError(\"Not Yet Implemented: CIELab\");\n                            break;\n                        // Unknown Photometric Interpretation\n                        default:\n                            throw RangeError(\"Unknown Photometric Interpretation:\", photometricInterpretation);\n                            break;\n                    }\n                    ctx.fillStyle = makeRGBAFillValue(red, green, blue, opacity);\n                    ctx.fillRect(x, yPadding + y, 1, 1);\n                }\n            }\n            numRowsInPreviousStrip = numRowsInStrip;\n        }\n    }\n    return canvas;\n};\n"]},"metadata":{},"sourceType":"script"}