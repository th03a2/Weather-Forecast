{"ast":null,"code":"/* Copyright 2016 Yury Karpovich\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/*\n MSG Reader\n */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    // AMD\n    define(['./DataStream'], factory);\n  } else if (typeof exports === 'object') {\n    // Node, CommonJS-like\n    module.exports = factory(require('./DataStream'));\n  } else {\n    // Browser globals (root is window)\n    root.MSGReader = factory(root.DataStream);\n  }\n})(this, function (DataStream) {\n  // constants\n  var CONST = {\n    FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),\n    MSG: {\n      UNUSED_BLOCK: -1,\n      END_OF_CHAIN: -2,\n      S_BIG_BLOCK_SIZE: 0x0200,\n      S_BIG_BLOCK_MARK: 9,\n      L_BIG_BLOCK_SIZE: 0x1000,\n      L_BIG_BLOCK_MARK: 12,\n      SMALL_BLOCK_SIZE: 0x0040,\n      BIG_BLOCK_MIN_DOC_SIZE: 0x1000,\n      HEADER: {\n        PROPERTY_START_OFFSET: 0x30,\n        BAT_START_OFFSET: 0x4c,\n        BAT_COUNT_OFFSET: 0x2C,\n        SBAT_START_OFFSET: 0x3C,\n        SBAT_COUNT_OFFSET: 0x40,\n        XBAT_START_OFFSET: 0x44,\n        XBAT_COUNT_OFFSET: 0x48\n      },\n      PROP: {\n        NO_INDEX: -1,\n        PROPERTY_SIZE: 0x0080,\n        NAME_SIZE_OFFSET: 0x40,\n        MAX_NAME_LENGTH:\n        /*NAME_SIZE_OFFSET*/\n        0x40 / 2 - 1,\n        TYPE_OFFSET: 0x42,\n        PREVIOUS_PROPERTY_OFFSET: 0x44,\n        NEXT_PROPERTY_OFFSET: 0x48,\n        CHILD_PROPERTY_OFFSET: 0x4C,\n        START_BLOCK_OFFSET: 0x74,\n        SIZE_OFFSET: 0x78,\n        TYPE_ENUM: {\n          DIRECTORY: 1,\n          DOCUMENT: 2,\n          ROOT: 5\n        }\n      },\n      FIELD: {\n        PREFIX: {\n          ATTACHMENT: '__attach_version1.0',\n          RECIPIENT: '__recip_version1.0',\n          DOCUMENT: '__substg1.'\n        },\n        // example (use fields as needed)\n        NAME_MAPPING: {\n          // email specific\n          '0037': 'subject',\n          '0c1a': 'senderName',\n          '5d02': 'senderEmail',\n          '1000': 'body',\n          '007d': 'headers',\n          // attachment specific\n          '3703': 'extension',\n          '3704': 'fileNameShort',\n          '3707': 'fileName',\n          '3712': 'pidContentId',\n          // recipient specific\n          '3001': 'name',\n          '39fe': 'email'\n        },\n        CLASS_MAPPING: {\n          ATTACHMENT_DATA: '3701'\n        },\n        TYPE_MAPPING: {\n          '001e': 'string',\n          '001f': 'unicode',\n          '0102': 'binary'\n        },\n        DIR_TYPE: {\n          INNER_MSG: '000d'\n        }\n      }\n    }\n  }; // unit utils\n\n  function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n\n    return true;\n  }\n\n  function uInt2int(data) {\n    var result = new Array(data.length);\n\n    for (var i = 0; i < data.length; i++) {\n      result[i] = data[i] << 24 >> 24;\n    }\n\n    return result;\n  } // MSG Reader implementation\n  // check MSG file header\n\n\n  function isMSGFile(ds) {\n    ds.seek(0);\n    return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));\n  } // FAT utils\n\n\n  function getBlockOffsetAt(msgData, offset) {\n    return (offset + 1) * msgData.bigBlockSize;\n  }\n\n  function getBlockAt(ds, msgData, offset) {\n    var startOffset = getBlockOffsetAt(msgData, offset);\n    ds.seek(startOffset);\n    return ds.readInt32Array(msgData.bigBlockLength);\n  }\n\n  function getNextBlockInner(ds, msgData, offset, blockOffsetData) {\n    var currentBlock = Math.floor(offset / msgData.bigBlockLength);\n    var currentBlockIndex = offset % msgData.bigBlockLength;\n    var startBlockOffset = blockOffsetData[currentBlock];\n    return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];\n  }\n\n  function getNextBlock(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.batData);\n  }\n\n  function getNextBlockSmall(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.sbatData);\n  } // convert binary data to dictionary\n\n\n  function parseMsgData(ds) {\n    var msgData = headerData(ds);\n    msgData.batData = batData(ds, msgData);\n    msgData.sbatData = sbatData(ds, msgData);\n\n    if (msgData.xbatCount > 0) {\n      xbatData(ds, msgData);\n    }\n\n    msgData.propertyData = propertyData(ds, msgData);\n    msgData.fieldsData = fieldsData(ds, msgData);\n    return msgData;\n  } // extract header data\n\n\n  function headerData(ds) {\n    var headerData = {}; // system data\n\n    headerData.bigBlockSize = ds.readByte(\n    /*const position*/\n    30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;\n    headerData.bigBlockLength = headerData.bigBlockSize / 4;\n    headerData.xBlockLength = headerData.bigBlockLength - 1; // header data\n\n    headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);\n    headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);\n    headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);\n    headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);\n    headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);\n    headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);\n    return headerData;\n  }\n\n  function batCountInHeader(msgData) {\n    var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;\n    return Math.min(msgData.batCount, maxBatsInHeader);\n  }\n\n  function batData(ds, msgData) {\n    var result = new Array(batCountInHeader(msgData));\n    ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);\n\n    for (var i = 0; i < result.length; i++) {\n      result[i] = ds.readInt32();\n    }\n\n    return result;\n  }\n\n  function sbatData(ds, msgData) {\n    var result = [];\n    var startIndex = msgData.sbatStart;\n\n    for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {\n      result.push(startIndex);\n      startIndex = getNextBlock(ds, msgData, startIndex);\n    }\n\n    return result;\n  }\n\n  function xbatData(ds, msgData) {\n    var batCount = batCountInHeader(msgData);\n    var batCountTotal = msgData.batCount;\n    var remainingBlocks = batCountTotal - batCount;\n    var nextBlockAt = msgData.xbatStart;\n\n    for (var i = 0; i < msgData.xbatCount; i++) {\n      var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);\n      nextBlockAt = xBatBlock[msgData.xBlockLength];\n      var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);\n\n      for (var j = 0; j < blocksToProcess; j++) {\n        var blockStartAt = xBatBlock[j];\n\n        if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {\n          break;\n        }\n\n        msgData.batData.push(blockStartAt);\n      }\n\n      remainingBlocks -= blocksToProcess;\n    }\n  } // extract property data and property hierarchy\n\n\n  function propertyData(ds, msgData) {\n    var props = [];\n    var currentOffset = msgData.propertyStart;\n\n    while (currentOffset != CONST.MSG.END_OF_CHAIN) {\n      convertBlockToProperties(ds, msgData, currentOffset, props);\n      currentOffset = getNextBlock(ds, msgData, currentOffset);\n    }\n\n    createPropertyHierarchy(props,\n    /*property with index 0 (zero) always as root*/\n    props[0]);\n    return props;\n  }\n\n  function convertName(ds, offset) {\n    var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);\n\n    if (nameLength < 1) {\n      return '';\n    } else {\n      return ds.readStringAt(offset, nameLength / 2);\n    }\n  }\n\n  function convertProperty(ds, index, offset) {\n    return {\n      index: index,\n      type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),\n      name: convertName(ds, offset),\n      // hierarchy\n      previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),\n      nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),\n      childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),\n      // data offset\n      startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),\n      sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)\n    };\n  }\n\n  function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {\n    var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;\n    var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);\n\n    for (var i = 0; i < propertyCount; i++) {\n      var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);\n\n      switch (propertyType) {\n        case CONST.MSG.PROP.TYPE_ENUM.ROOT:\n        case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:\n        case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:\n          props.push(convertProperty(ds, props.length, propertyOffset));\n          break;\n\n        default:\n          /* unknown property types */\n          props.push(null);\n      }\n\n      propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;\n    }\n  }\n\n  function createPropertyHierarchy(props, nodeProperty) {\n    if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {\n      return;\n    }\n\n    nodeProperty.children = [];\n    var children = [nodeProperty.childProperty];\n\n    while (children.length != 0) {\n      var currentIndex = children.shift();\n      var current = props[currentIndex];\n\n      if (current == null) {\n        continue;\n      }\n\n      nodeProperty.children.push(currentIndex);\n\n      if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n        createPropertyHierarchy(props, current);\n      }\n\n      if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.previousProperty);\n      }\n\n      if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.nextProperty);\n      }\n    }\n  } // extract real fields\n\n\n  function fieldsData(ds, msgData) {\n    var fields = {\n      attachments: [],\n      recipients: []\n    };\n    fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);\n    return fields;\n  }\n\n  function fieldsDataDir(ds, msgData, dirProperty, fields) {\n    if (dirProperty.children && dirProperty.children.length > 0) {\n      for (var i = 0; i < dirProperty.children.length; i++) {\n        var childProperty = msgData.propertyData[dirProperty.children[i]];\n\n        if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n          fieldsDataDirInner(ds, msgData, childProperty, fields);\n        } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {\n          fieldsDataDocument(ds, msgData, childProperty, fields);\n        }\n      }\n    }\n  }\n\n  function fieldsDataDirInner(ds, msgData, dirProperty, fields) {\n    if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {\n      // attachment\n      var attachmentField = {};\n      fields.attachments.push(attachmentField);\n      fieldsDataDir(ds, msgData, dirProperty, attachmentField);\n    } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {\n      // recipient\n      var recipientField = {};\n      fields.recipients.push(recipientField);\n      fieldsDataDir(ds, msgData, dirProperty, recipientField);\n    } else {\n      // other dir\n      var childFieldType = getFieldType(dirProperty);\n\n      if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {\n        fieldsDataDir(ds, msgData, dirProperty, fields);\n      } else {\n        // MSG as attachment currently isn't supported\n        fields.innerMsgContent = true;\n      }\n    }\n  }\n\n  function fieldsDataDocument(ds, msgData, documentProperty, fields) {\n    var value = documentProperty.name.substring(12).toLowerCase();\n    var fieldClass = value.substring(0, 4);\n    var fieldType = value.substring(4, 8);\n    var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];\n\n    if (fieldName) {\n      fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);\n    }\n\n    if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {\n      // attachment specific info\n      fields['dataId'] = documentProperty.index;\n      fields['contentLength'] = documentProperty.sizeBlock;\n    }\n  }\n\n  function getFieldType(fieldProperty) {\n    var value = fieldProperty.name.substring(12).toLowerCase();\n    return value.substring(4, 8);\n  } // extractor structure to manage bat/sbat block types and different data types\n\n\n  var extractorFieldValue = {\n    sbat: {\n      'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var chain = getChainByBlockSmall(ds, msgData, fieldProperty);\n\n        if (chain.length == 1) {\n          return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);\n        } else if (chain.length > 1) {\n          return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);\n        }\n\n        return null;\n      },\n      dataType: {\n        'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readString(blockSize);\n        },\n        'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readUCS2String(blockSize / 2);\n        },\n        'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);\n          return ds.readUint8Array(toReadLength);\n        }\n      }\n    },\n    bat: {\n      'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);\n        ds.seek(offset);\n        return dataTypeExtractor(ds, fieldProperty);\n      },\n      dataType: {\n        'string': function extractSbatString(ds, fieldProperty) {\n          return ds.readString(fieldProperty.sizeBlock);\n        },\n        'unicode': function extractSbatUnicode(ds, fieldProperty) {\n          return ds.readUCS2String(fieldProperty.sizeBlock / 2);\n        },\n        'binary': function extractSbatBinary(ds, fieldProperty) {\n          return ds.readUint8Array(fieldProperty.sizeBlock);\n        }\n      }\n    }\n  };\n\n  function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {\n    var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;\n    var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);\n    var bigBlockOffset = byteOffset % msgData.bigBlockSize;\n    var rootProp = msgData.propertyData[0];\n    var nextBlock = rootProp.startBlock;\n\n    for (var i = 0; i < bigBlockNumber; i++) {\n      nextBlock = getNextBlock(ds, msgData, nextBlock);\n    }\n\n    var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);\n    return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);\n  }\n\n  function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {\n    var resultData = new Int8Array(fieldProperty.sizeBlock);\n\n    for (var i = 0, idx = 0; i < chain.length; i++) {\n      var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);\n\n      for (var j = 0; j < data.length; j++) {\n        resultData[idx++] = data[j];\n      }\n    }\n\n    var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);\n    return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);\n  }\n\n  function getChainByBlockSmall(ds, msgData, fieldProperty) {\n    var blockChain = [];\n    var nextBlockSmall = fieldProperty.startBlock;\n\n    while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {\n      blockChain.push(nextBlockSmall);\n      nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);\n    }\n\n    return blockChain;\n  }\n\n  function getFieldValue(ds, msgData, fieldProperty, type) {\n    var value = null;\n    var valueExtractor = fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;\n    var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];\n\n    if (dataTypeExtractor) {\n      value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);\n    }\n\n    return value;\n  } // MSG Reader\n\n\n  var MSGReader = function MSGReader(arrayBuffer) {\n    this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n  };\n\n  MSGReader.prototype = {\n    /**\n     Converts bytes to fields information\n      @return {Object} The fields data for MSG file\n     */\n    getFileData: function getFileData() {\n      if (!isMSGFile(this.ds)) {\n        return {\n          error: 'Unsupported file type!'\n        };\n      }\n\n      if (this.fileData == null) {\n        this.fileData = parseMsgData(this.ds);\n      }\n\n      return this.fileData.fieldsData;\n    },\n\n    /**\n     Reads an attachment content by key/ID\n      @return {Object} The attachment for specific attachment key\n     */\n    getAttachment: function getAttachment(attach) {\n      var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;\n      var fieldProperty = this.fileData.propertyData[attachData.dataId];\n      var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));\n      return {\n        fileName: attachData.fileName,\n        content: fieldData\n      };\n    }\n  };\n  return MSGReader;\n});","map":{"version":3,"sources":["C:/xampp/htdocs/mdbreact/node_modules/wl-msg-reader/lib/msg.reader.js"],"names":["root","factory","define","amd","exports","module","require","MSGReader","DataStream","CONST","FILE_HEADER","uInt2int","MSG","UNUSED_BLOCK","END_OF_CHAIN","S_BIG_BLOCK_SIZE","S_BIG_BLOCK_MARK","L_BIG_BLOCK_SIZE","L_BIG_BLOCK_MARK","SMALL_BLOCK_SIZE","BIG_BLOCK_MIN_DOC_SIZE","HEADER","PROPERTY_START_OFFSET","BAT_START_OFFSET","BAT_COUNT_OFFSET","SBAT_START_OFFSET","SBAT_COUNT_OFFSET","XBAT_START_OFFSET","XBAT_COUNT_OFFSET","PROP","NO_INDEX","PROPERTY_SIZE","NAME_SIZE_OFFSET","MAX_NAME_LENGTH","TYPE_OFFSET","PREVIOUS_PROPERTY_OFFSET","NEXT_PROPERTY_OFFSET","CHILD_PROPERTY_OFFSET","START_BLOCK_OFFSET","SIZE_OFFSET","TYPE_ENUM","DIRECTORY","DOCUMENT","ROOT","FIELD","PREFIX","ATTACHMENT","RECIPIENT","NAME_MAPPING","CLASS_MAPPING","ATTACHMENT_DATA","TYPE_MAPPING","DIR_TYPE","INNER_MSG","arraysEqual","a","b","length","i","data","result","Array","isMSGFile","ds","seek","readInt8Array","getBlockOffsetAt","msgData","offset","bigBlockSize","getBlockAt","startOffset","readInt32Array","bigBlockLength","getNextBlockInner","blockOffsetData","currentBlock","Math","floor","currentBlockIndex","startBlockOffset","getNextBlock","batData","getNextBlockSmall","sbatData","parseMsgData","headerData","xbatCount","xbatData","propertyData","fieldsData","readByte","xBlockLength","batCount","readInt","propertyStart","sbatStart","sbatCount","xbatStart","batCountInHeader","maxBatsInHeader","min","readInt32","startIndex","push","batCountTotal","remainingBlocks","nextBlockAt","xBatBlock","blocksToProcess","j","blockStartAt","props","currentOffset","convertBlockToProperties","createPropertyHierarchy","convertName","nameLength","readShort","readStringAt","convertProperty","index","type","name","previousProperty","nextProperty","childProperty","startBlock","sizeBlock","propertyBlockOffset","propertyCount","propertyOffset","propertyType","nodeProperty","children","currentIndex","shift","current","fields","attachments","recipients","fieldsDataDir","dirProperty","fieldsDataDirInner","indexOf","fieldsDataDocument","attachmentField","recipientField","childFieldType","getFieldType","innerMsgContent","documentProperty","value","substring","toLowerCase","fieldClass","fieldType","fieldName","getFieldValue","fieldProperty","extractorFieldValue","sbat","extractDataViaSbat","dataTypeExtractor","chain","getChainByBlockSmall","readDataByBlockSmall","readChainDataByBlockSmall","dataType","extractBatString","blockStartOffset","bigBlockOffset","blockSize","readString","extractBatUnicode","readUCS2String","extractBatBinary","toReadLength","readUint8Array","bat","extractDataViaBat","extractSbatString","extractSbatUnicode","extractSbatBinary","byteOffset","bigBlockNumber","rootProp","nextBlock","resultData","Int8Array","idx","binary","localDs","LITTLE_ENDIAN","blockChain","nextBlockSmall","valueExtractor","extractor","arrayBuffer","prototype","getFileData","error","fileData","getAttachment","attach","attachData","dataId","fieldData","fileName","content"],"mappings":"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","sourcesContent":["/* Copyright 2016 Yury Karpovich\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/*\n MSG Reader\n */\n\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['./DataStream'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('./DataStream'));\n    } else {\n        // Browser globals (root is window)\n        root.MSGReader = factory(root.DataStream);\n    }\n}(this, function (DataStream) {\n\n  // constants\n  var CONST = {\n    FILE_HEADER: uInt2int([0xD0, 0xCF, 0x11, 0xE0, 0xA1, 0xB1, 0x1A, 0xE1]),\n    MSG: {\n      UNUSED_BLOCK: -1,\n      END_OF_CHAIN: -2,\n\n      S_BIG_BLOCK_SIZE: 0x0200,\n      S_BIG_BLOCK_MARK: 9,\n\n      L_BIG_BLOCK_SIZE: 0x1000,\n      L_BIG_BLOCK_MARK: 12,\n\n      SMALL_BLOCK_SIZE: 0x0040,\n      BIG_BLOCK_MIN_DOC_SIZE: 0x1000,\n      HEADER: {\n        PROPERTY_START_OFFSET: 0x30,\n\n        BAT_START_OFFSET: 0x4c,\n        BAT_COUNT_OFFSET: 0x2C,\n\n        SBAT_START_OFFSET: 0x3C,\n        SBAT_COUNT_OFFSET: 0x40,\n\n        XBAT_START_OFFSET: 0x44,\n        XBAT_COUNT_OFFSET: 0x48\n      },\n      PROP: {\n        NO_INDEX: -1,\n        PROPERTY_SIZE: 0x0080,\n\n        NAME_SIZE_OFFSET: 0x40,\n        MAX_NAME_LENGTH: (/*NAME_SIZE_OFFSET*/0x40 / 2) - 1,\n        TYPE_OFFSET: 0x42,\n        PREVIOUS_PROPERTY_OFFSET: 0x44,\n        NEXT_PROPERTY_OFFSET: 0x48,\n        CHILD_PROPERTY_OFFSET: 0x4C,\n        START_BLOCK_OFFSET: 0x74,\n        SIZE_OFFSET: 0x78,\n        TYPE_ENUM: {\n          DIRECTORY: 1,\n          DOCUMENT: 2,\n          ROOT: 5\n        }\n      },\n      FIELD: {\n        PREFIX: {\n          ATTACHMENT: '__attach_version1.0',\n          RECIPIENT: '__recip_version1.0',\n          DOCUMENT: '__substg1.'\n        },\n        // example (use fields as needed)\n        NAME_MAPPING: {\n          // email specific\n          '0037': 'subject',\n          '0c1a': 'senderName',\n          '5d02': 'senderEmail',\n          '1000': 'body',\n          '007d': 'headers',\n          // attachment specific\n          '3703': 'extension',\n          '3704': 'fileNameShort',\n          '3707': 'fileName',\n          '3712': 'pidContentId',\n          // recipient specific\n          '3001': 'name',\n          '39fe': 'email'\n        },\n        CLASS_MAPPING: {\n          ATTACHMENT_DATA: '3701'\n        },\n        TYPE_MAPPING: {\n          '001e': 'string',\n          '001f': 'unicode',\n          '0102': 'binary'\n        },\n        DIR_TYPE: {\n          INNER_MSG: '000d'\n        }\n      }\n    }\n  };\n\n  // unit utils\n  function arraysEqual(a, b) {\n    if (a === b) return true;\n    if (a == null || b == null) return false;\n    if (a.length != b.length) return false;\n\n    for (var i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n\n  function uInt2int(data) {\n    var result = new Array(data.length);\n    for (var i = 0; i < data.length; i++) {\n      result[i] = data[i] << 24 >> 24;\n    }\n    return result;\n  }\n\n  // MSG Reader implementation\n\n  // check MSG file header\n  function isMSGFile(ds) {\n    ds.seek(0);\n    return arraysEqual(CONST.FILE_HEADER, ds.readInt8Array(CONST.FILE_HEADER.length));\n  }\n\n  // FAT utils\n  function getBlockOffsetAt(msgData, offset) {\n    return (offset + 1) * msgData.bigBlockSize;\n  }\n\n  function getBlockAt(ds, msgData, offset) {\n    var startOffset = getBlockOffsetAt(msgData, offset);\n    ds.seek(startOffset);\n    return ds.readInt32Array(msgData.bigBlockLength);\n  }\n\n  function getNextBlockInner(ds, msgData, offset, blockOffsetData) {\n    var currentBlock = Math.floor(offset / msgData.bigBlockLength);\n    var currentBlockIndex = offset % msgData.bigBlockLength;\n\n    var startBlockOffset = blockOffsetData[currentBlock];\n\n    return getBlockAt(ds, msgData, startBlockOffset)[currentBlockIndex];\n  }\n\n  function getNextBlock(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.batData);\n  }\n\n  function getNextBlockSmall(ds, msgData, offset) {\n    return getNextBlockInner(ds, msgData, offset, msgData.sbatData);\n  }\n\n  // convert binary data to dictionary\n  function parseMsgData(ds) {\n    var msgData = headerData(ds);\n    msgData.batData = batData(ds, msgData);\n    msgData.sbatData = sbatData(ds, msgData);\n    if (msgData.xbatCount > 0) {\n      xbatData(ds, msgData);\n    }\n    msgData.propertyData = propertyData(ds, msgData);\n    msgData.fieldsData = fieldsData(ds, msgData);\n\n    return msgData;\n  }\n\n  // extract header data\n  function headerData(ds) {\n    var headerData = {};\n\n    // system data\n    headerData.bigBlockSize =\n      ds.readByte(/*const position*/30) == CONST.MSG.L_BIG_BLOCK_MARK ? CONST.MSG.L_BIG_BLOCK_SIZE : CONST.MSG.S_BIG_BLOCK_SIZE;\n    headerData.bigBlockLength = headerData.bigBlockSize / 4;\n    headerData.xBlockLength = headerData.bigBlockLength - 1;\n\n    // header data\n    headerData.batCount = ds.readInt(CONST.MSG.HEADER.BAT_COUNT_OFFSET);\n    headerData.propertyStart = ds.readInt(CONST.MSG.HEADER.PROPERTY_START_OFFSET);\n    headerData.sbatStart = ds.readInt(CONST.MSG.HEADER.SBAT_START_OFFSET);\n    headerData.sbatCount = ds.readInt(CONST.MSG.HEADER.SBAT_COUNT_OFFSET);\n    headerData.xbatStart = ds.readInt(CONST.MSG.HEADER.XBAT_START_OFFSET);\n    headerData.xbatCount = ds.readInt(CONST.MSG.HEADER.XBAT_COUNT_OFFSET);\n\n    return headerData;\n  }\n\n  function batCountInHeader(msgData) {\n    var maxBatsInHeader = (CONST.MSG.S_BIG_BLOCK_SIZE - CONST.MSG.HEADER.BAT_START_OFFSET) / 4;\n    return Math.min(msgData.batCount, maxBatsInHeader);\n  }\n\n  function batData(ds, msgData) {\n    var result = new Array(batCountInHeader(msgData));\n    ds.seek(CONST.MSG.HEADER.BAT_START_OFFSET);\n    for (var i = 0; i < result.length; i++) {\n      result[i] = ds.readInt32()\n    }\n    return result;\n  }\n\n  function sbatData(ds, msgData) {\n    var result = [];\n    var startIndex = msgData.sbatStart;\n\n    for (var i = 0; i < msgData.sbatCount && startIndex != CONST.MSG.END_OF_CHAIN; i++) {\n      result.push(startIndex);\n      startIndex = getNextBlock(ds, msgData, startIndex);\n    }\n    return result;\n  }\n\n  function xbatData(ds, msgData) {\n    var batCount = batCountInHeader(msgData);\n    var batCountTotal = msgData.batCount;\n    var remainingBlocks = batCountTotal - batCount;\n\n    var nextBlockAt = msgData.xbatStart;\n    for (var i = 0; i < msgData.xbatCount; i++) {\n      var xBatBlock = getBlockAt(ds, msgData, nextBlockAt);\n      nextBlockAt = xBatBlock[msgData.xBlockLength];\n\n      var blocksToProcess = Math.min(remainingBlocks, msgData.xBlockLength);\n      for (var j = 0; j < blocksToProcess; j++) {\n        var blockStartAt = xBatBlock[j];\n        if (blockStartAt == CONST.MSG.UNUSED_BLOCK || blockStartAt == CONST.MSG.END_OF_CHAIN) {\n          break;\n        }\n        msgData.batData.push(blockStartAt);\n      }\n      remainingBlocks -= blocksToProcess;\n    }\n  }\n\n  // extract property data and property hierarchy\n  function propertyData(ds, msgData) {\n    var props = [];\n\n    var currentOffset = msgData.propertyStart;\n\n    while (currentOffset != CONST.MSG.END_OF_CHAIN) {\n      convertBlockToProperties(ds, msgData, currentOffset, props);\n      currentOffset = getNextBlock(ds, msgData, currentOffset);\n    }\n    createPropertyHierarchy(props, /*property with index 0 (zero) always as root*/props[0]);\n    return props;\n  }\n\n  function convertName(ds, offset) {\n    var nameLength = ds.readShort(offset + CONST.MSG.PROP.NAME_SIZE_OFFSET);\n    if (nameLength < 1) {\n      return '';\n    } else {\n      return ds.readStringAt(offset, nameLength / 2);\n    }\n  }\n\n  function convertProperty(ds, index, offset) {\n    return {\n      index: index,\n      type: ds.readByte(offset + CONST.MSG.PROP.TYPE_OFFSET),\n      name: convertName(ds, offset),\n      // hierarchy\n      previousProperty: ds.readInt(offset + CONST.MSG.PROP.PREVIOUS_PROPERTY_OFFSET),\n      nextProperty: ds.readInt(offset + CONST.MSG.PROP.NEXT_PROPERTY_OFFSET),\n      childProperty: ds.readInt(offset + CONST.MSG.PROP.CHILD_PROPERTY_OFFSET),\n      // data offset\n      startBlock: ds.readInt(offset + CONST.MSG.PROP.START_BLOCK_OFFSET),\n      sizeBlock: ds.readInt(offset + CONST.MSG.PROP.SIZE_OFFSET)\n    };\n  }\n\n  function convertBlockToProperties(ds, msgData, propertyBlockOffset, props) {\n\n    var propertyCount = msgData.bigBlockSize / CONST.MSG.PROP.PROPERTY_SIZE;\n    var propertyOffset = getBlockOffsetAt(msgData, propertyBlockOffset);\n\n    for (var i = 0; i < propertyCount; i++) {\n      var propertyType = ds.readByte(propertyOffset + CONST.MSG.PROP.TYPE_OFFSET);\n      switch (propertyType) {\n        case CONST.MSG.PROP.TYPE_ENUM.ROOT:\n        case CONST.MSG.PROP.TYPE_ENUM.DIRECTORY:\n        case CONST.MSG.PROP.TYPE_ENUM.DOCUMENT:\n          props.push(convertProperty(ds, props.length, propertyOffset));\n          break;\n        default:\n          /* unknown property types */\n          props.push(null);\n      }\n\n      propertyOffset += CONST.MSG.PROP.PROPERTY_SIZE;\n    }\n  }\n\n  function createPropertyHierarchy(props, nodeProperty) {\n\n    if (nodeProperty.childProperty == CONST.MSG.PROP.NO_INDEX) {\n      return;\n    }\n    nodeProperty.children = [];\n\n    var children = [nodeProperty.childProperty];\n    while (children.length != 0) {\n      var currentIndex = children.shift();\n      var current = props[currentIndex];\n      if (current == null) {\n        continue;\n      }\n      nodeProperty.children.push(currentIndex);\n\n      if (current.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n        createPropertyHierarchy(props, current);\n      }\n      if (current.previousProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.previousProperty);\n      }\n      if (current.nextProperty != CONST.MSG.PROP.NO_INDEX) {\n        children.push(current.nextProperty);\n      }\n    }\n  }\n\n  // extract real fields\n  function fieldsData(ds, msgData) {\n    var fields = {\n      attachments: [],\n      recipients: []\n    };\n    fieldsDataDir(ds, msgData, msgData.propertyData[0], fields);\n    return fields;\n  }\n\n  function fieldsDataDir(ds, msgData, dirProperty, fields) {\n\n    if (dirProperty.children && dirProperty.children.length > 0) {\n      for (var i = 0; i < dirProperty.children.length; i++) {\n        var childProperty = msgData.propertyData[dirProperty.children[i]];\n\n        if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DIRECTORY) {\n          fieldsDataDirInner(ds, msgData, childProperty, fields)\n        } else if (childProperty.type == CONST.MSG.PROP.TYPE_ENUM.DOCUMENT\n          && childProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.DOCUMENT) == 0) {\n          fieldsDataDocument(ds, msgData, childProperty, fields);\n        }\n      }\n    }\n  }\n\n  function fieldsDataDirInner(ds, msgData, dirProperty, fields) {\n    if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.ATTACHMENT) == 0) {\n\n      // attachment\n      var attachmentField = {};\n      fields.attachments.push(attachmentField);\n      fieldsDataDir(ds, msgData, dirProperty, attachmentField);\n    } else if (dirProperty.name.indexOf(CONST.MSG.FIELD.PREFIX.RECIPIENT) == 0) {\n\n      // recipient\n      var recipientField = {};\n      fields.recipients.push(recipientField);\n      fieldsDataDir(ds, msgData, dirProperty, recipientField);\n    } else {\n\n      // other dir\n      var childFieldType = getFieldType(dirProperty);\n      if (childFieldType != CONST.MSG.FIELD.DIR_TYPE.INNER_MSG) {\n        fieldsDataDir(ds, msgData, dirProperty, fields);\n      } else {\n        // MSG as attachment currently isn't supported\n        fields.innerMsgContent = true;\n      }\n    }\n  }\n\n  function fieldsDataDocument(ds, msgData, documentProperty, fields) {\n    var value = documentProperty.name.substring(12).toLowerCase();\n    var fieldClass = value.substring(0, 4);\n    var fieldType = value.substring(4, 8);\n\n    var fieldName = CONST.MSG.FIELD.NAME_MAPPING[fieldClass];\n\n    if (fieldName) {\n      fields[fieldName] = getFieldValue(ds, msgData, documentProperty, fieldType);\n    }\n    if (fieldClass == CONST.MSG.FIELD.CLASS_MAPPING.ATTACHMENT_DATA) {\n\n      // attachment specific info\n      fields['dataId'] = documentProperty.index;\n      fields['contentLength'] = documentProperty.sizeBlock;\n    }\n  }\n\n  function getFieldType(fieldProperty) {\n    var value = fieldProperty.name.substring(12).toLowerCase();\n    return value.substring(4, 8);\n  }\n\n  // extractor structure to manage bat/sbat block types and different data types\n  var extractorFieldValue = {\n    sbat: {\n      'extractor': function extractDataViaSbat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var chain = getChainByBlockSmall(ds, msgData, fieldProperty);\n        if (chain.length == 1) {\n          return readDataByBlockSmall(ds, msgData, fieldProperty.startBlock, fieldProperty.sizeBlock, dataTypeExtractor);\n        } else if (chain.length > 1) {\n          return readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor);\n        }\n        return null;\n      },\n      dataType: {\n        'string': function extractBatString(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readString(blockSize);\n        },\n        'unicode': function extractBatUnicode(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          return ds.readUCS2String(blockSize / 2);\n        },\n        'binary': function extractBatBinary(ds, msgData, blockStartOffset, bigBlockOffset, blockSize) {\n          ds.seek(blockStartOffset + bigBlockOffset);\n          var toReadLength = Math.min(Math.min(msgData.bigBlockSize - bigBlockOffset, blockSize), CONST.MSG.SMALL_BLOCK_SIZE);\n          return ds.readUint8Array(toReadLength);\n        }\n      }\n    },\n    bat: {\n      'extractor': function extractDataViaBat(ds, msgData, fieldProperty, dataTypeExtractor) {\n        var offset = getBlockOffsetAt(msgData, fieldProperty.startBlock);\n        ds.seek(offset);\n        return dataTypeExtractor(ds, fieldProperty);\n      },\n      dataType: {\n        'string': function extractSbatString(ds, fieldProperty) {\n          return ds.readString(fieldProperty.sizeBlock);\n        },\n        'unicode': function extractSbatUnicode(ds, fieldProperty) {\n          return ds.readUCS2String(fieldProperty.sizeBlock / 2);\n        },\n        'binary': function extractSbatBinary(ds, fieldProperty) {\n          return ds.readUint8Array(fieldProperty.sizeBlock);\n        }\n      }\n    }\n  };\n\n  function readDataByBlockSmall(ds, msgData, startBlock, blockSize, dataTypeExtractor) {\n    var byteOffset = startBlock * CONST.MSG.SMALL_BLOCK_SIZE;\n    var bigBlockNumber = Math.floor(byteOffset / msgData.bigBlockSize);\n    var bigBlockOffset = byteOffset % msgData.bigBlockSize;\n\n    var rootProp = msgData.propertyData[0];\n\n    var nextBlock = rootProp.startBlock;\n    for (var i = 0; i < bigBlockNumber; i++) {\n      nextBlock = getNextBlock(ds, msgData, nextBlock);\n    }\n    var blockStartOffset = getBlockOffsetAt(msgData, nextBlock);\n\n    return dataTypeExtractor(ds, msgData, blockStartOffset, bigBlockOffset, blockSize);\n  }\n\n  function readChainDataByBlockSmall(ds, msgData, fieldProperty, chain, dataTypeExtractor) {\n    var resultData = new Int8Array(fieldProperty.sizeBlock);\n\n    for (var i = 0, idx = 0; i < chain.length; i++) {\n      var data = readDataByBlockSmall(ds, msgData, chain[i], CONST.MSG.SMALL_BLOCK_SIZE, extractorFieldValue.sbat.dataType.binary);\n      for (var j = 0; j < data.length; j++) {\n        resultData[idx++] = data[j];\n      }\n    }\n    var localDs = new DataStream(resultData, 0, DataStream.LITTLE_ENDIAN);\n    return dataTypeExtractor(localDs, msgData, 0, 0, fieldProperty.sizeBlock);\n  }\n\n  function getChainByBlockSmall(ds, msgData, fieldProperty) {\n    var blockChain = [];\n    var nextBlockSmall = fieldProperty.startBlock;\n    while (nextBlockSmall != CONST.MSG.END_OF_CHAIN) {\n      blockChain.push(nextBlockSmall);\n      nextBlockSmall = getNextBlockSmall(ds, msgData, nextBlockSmall);\n    }\n    return blockChain;\n  }\n\n  function getFieldValue(ds, msgData, fieldProperty, type) {\n    var value = null;\n\n    var valueExtractor =\n      fieldProperty.sizeBlock < CONST.MSG.BIG_BLOCK_MIN_DOC_SIZE ? extractorFieldValue.sbat : extractorFieldValue.bat;\n    var dataTypeExtractor = valueExtractor.dataType[CONST.MSG.FIELD.TYPE_MAPPING[type]];\n\n    if (dataTypeExtractor) {\n      value = valueExtractor.extractor(ds, msgData, fieldProperty, dataTypeExtractor);\n    }\n    return value;\n  }\n\n  // MSG Reader\n  var MSGReader = function (arrayBuffer) {\n    this.ds = new DataStream(arrayBuffer, 0, DataStream.LITTLE_ENDIAN);\n  };\n\n  MSGReader.prototype = {\n    /**\n     Converts bytes to fields information\n\n     @return {Object} The fields data for MSG file\n     */\n    getFileData: function () {\n      if (!isMSGFile(this.ds)) {\n        return {error: 'Unsupported file type!'};\n      }\n      if (this.fileData == null) {\n        this.fileData = parseMsgData(this.ds);\n      }\n      return this.fileData.fieldsData;\n    },\n    /**\n     Reads an attachment content by key/ID\n\n     @return {Object} The attachment for specific attachment key\n     */\n    getAttachment: function (attach) {\n      var attachData = typeof attach === 'number' ? this.fileData.fieldsData.attachments[attach] : attach;\n      var fieldProperty = this.fileData.propertyData[attachData.dataId];\n      var fieldData = getFieldValue(this.ds, this.fileData, fieldProperty, getFieldType(fieldProperty));\n\n      return {fileName: attachData.fileName, content: fieldData};\n    }\n  };\n\n  return MSGReader;\n\n}));"]},"metadata":{},"sourceType":"script"}